"use strict";
(self["webpackChunkapp"] = self["webpackChunkapp"] || []).push([["default-node_modules_ngx-print-element_fesm2020_ngx-print-element_mjs"],{

/***/ 3412:
/*!***********************************************************************!*\
  !*** ./node_modules/ngx-print-element/fesm2020/ngx-print-element.mjs ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NgxPrintElementComponent": () => (/* binding */ NgxPrintElementComponent),
/* harmony export */   "NgxPrintElementDirective": () => (/* binding */ NgxPrintElementDirective),
/* harmony export */   "NgxPrintElementModule": () => (/* binding */ NgxPrintElementModule),
/* harmony export */   "NgxPrintElementService": () => (/* binding */ NgxPrintElementService)
/* harmony export */ });
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/core */ 2560);


/**
 * callPrint
 * @param printWindow
 * @param iframe
 */

const callPrint = (printWindow, iframe) => {
  if (printWindow && printWindow.printPage) {
    printWindow.printPage();

    if (iframe) {
      document.body.removeChild(iframe);
    }
  } else {
    setTimeout(() => {
      callPrint(printWindow, iframe);
    }, 50);
  }
};
/**
 * getBaseHref
 * @returns
 */


const getBaseHref = () => {
  const port = window.location.port ? `:${window.location.port}` : '';
  return `${window.location.protocol}//${window.location.hostname}${port}${window.location.pathname}`;
};
/**
 * getMarkup
 * @param elementHtml
 * @param options
 * @returns
 */


const getMarkup = (elementHtml, options) => {
  const template = options.templateString;
  const templateRegex = new RegExp(/{{\s*printBody\s*}}/gi);
  let stylesheets;
  let styles;
  const html = [];

  if (template && templateRegex.test(template)) {
    elementHtml = template.replace(templateRegex, elementHtml);
  }

  html.push(`<html><head><title>${options.pageTitle || ''}</title>`); // If stylesheet URL's or list of stylesheet URL's are specified, override page stylesheets

  if (options.stylesheets) {
    stylesheets = Array.isArray(options.stylesheets) ? options.stylesheets : [options.stylesheets];
  } else {
    stylesheets = Array.prototype.slice.call(document.getElementsByTagName('link')).map(link => link);
  }

  stylesheets.forEach(f => {
    html.push(`<link rel="${f.rel}" href="${f.href}">`);
  }); // If inline styles or list of inline styles are specified, override inline styles

  if (options.styles) {
    styles = Array.isArray(options.styles) ? [...options.styles, `.print-none { display: none; }`] : [options.styles + `.print-none { display: none; }`];
  } else {
    styles = Array.prototype.slice.call(document.getElementsByTagName('style')).map(style => style.innerHTML);
  }

  styles.forEach(style => {
    html.push(`<style type="text/css">${style}</style>`);
  });
  html.push(`<base href="${getBaseHref()}"/>`);
  html.push('</head><body class="pe-body">');
  html.push(elementHtml);
  html.push(`
    <script type="text/javascript">
      function printPage() {
        focus();
        print();
        ${options.printMode.toLowerCase() === 'popup' ? 'close();' : ''}
      }
    </script>
  `);
  html.push('</body></html>');
  return html.join('');
};
/**
 * printHtml
 * @param element
 * @param selfOptions
 */


const printHtml = (element, selfOptions = {}) => {
  const defaultOptions = {
    htmlType: 'domObj',
    printMode: 'template',
    pageTitle: '',
    templateString: '',
    popupProperties: '',
    stylesheets: null,
    styles: null
  };
  const options = { ...defaultOptions,
    ...selfOptions
  };
  let html = element;

  if (options.htmlType === 'domObj') {
    html = element.outerHTML;
  } // Get markup to be printed


  const markup = getMarkup(html, options);
  let printWindow;
  let printIframe;
  let printDocument;
  let printElementID;

  if (options.printMode.toLowerCase() === 'popup') {
    printWindow = window.open('about:blank', 'printElementWindow', options.popupProperties);
    printDocument = printWindow?.document;
  } else {
    printElementID = `printElement_${Math.round(Math.random() * 99999).toString()}`;
    printIframe = document.createElement('iframe');
    printIframe.setAttribute('id', printElementID);
    printIframe.setAttribute('src', 'about:blank');
    printIframe.setAttribute('frameBorder', '0');
    printIframe.setAttribute('scrolling', 'no');
    printIframe.setAttribute('style', 'position:fixed;bottom:100%;right:100%;');
    document.body.appendChild(printIframe);
    printDocument = printIframe.contentWindow || printIframe.contentDocument;

    if (printDocument.document) {
      printDocument = printDocument.document;
    }

    printIframe = document.frames ? document.frames[printElementID] : document.getElementById(printElementID);
    printWindow = printIframe.contentWindow || printIframe;
  }

  focus();
  printDocument.open(); // SetTimeout fixesiframe printMode does not work in firefox

  setTimeout(() => {
    printDocument.write(markup);
    printDocument.close();
  });
  callPrint(printWindow, printIframe);
};

class NgxPrintElementService {
  constructor() {}
  /**
   * Print
   * @param id
   * @param config
   * @returns
   */


  print(id, config) {
    // Create and insert new print section
    const container = document.getElementById(id);

    switch (config && config.printMode) {
      case 'template':
        printHtml(container, { ...config,
          printMode: ''
        });
        break;

      case 'template-popup':
        printHtml(container, { ...config,
          printMode: 'popup'
        });
        break;

      default:
        if (container) {
          // Declare
          const domClone = container.cloneNode(true);
          const $printSection = document.createElement('div'); // Add visibility hidden into body

          const bodyEl = document.querySelector('body');

          if (bodyEl) {
            bodyEl.setAttribute('style', 'visibility: hidden !important;');
          } // Clone element container


          $printSection.id = 'ngx-print-element';
          $printSection.appendChild(domClone);
          document.body.insertBefore($printSection, document.body.firstChild); // Print

          window.print(); // Clean up print section for future use

          const oldElem = document.getElementById('ngx-print-element');

          if (oldElem) {
            oldElem?.parentNode?.removeChild(oldElem);
          }

          oldElem?.remove(); // Clear visibility: hidden

          bodyEl && (bodyEl.style.visibility = '');
        }

        break;
    }
  }

}

NgxPrintElementService.ɵfac = function NgxPrintElementService_Factory(t) {
  return new (t || NgxPrintElementService)();
};

NgxPrintElementService.ɵprov = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjectable"]({
  token: NgxPrintElementService,
  factory: NgxPrintElementService.ɵfac,
  providedIn: 'root'
});

(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵsetClassMetadata"](NgxPrintElementService, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Injectable,
    args: [{
      providedIn: 'root'
    }]
  }], function () {
    return [];
  }, null);
})();

class NgxPrintElementDirective {
  constructor(prints) {
    this.prints = prints;
    this.print = [];
  }
  /**
   * Print
   * @param event
   */


  onClick(event) {
    if (this.print && this.print.length === 1) {
      this.prints.print(this.print[0]);
    }

    if (this.print && this.print.length === 2) {
      this.prints.print(this.print[0], this.print[1]);
    }
  }

}

NgxPrintElementDirective.ɵfac = function NgxPrintElementDirective_Factory(t) {
  return new (t || NgxPrintElementDirective)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](NgxPrintElementService));
};

NgxPrintElementDirective.ɵdir = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineDirective"]({
  type: NgxPrintElementDirective,
  selectors: [["", "print", ""]],
  hostBindings: function NgxPrintElementDirective_HostBindings(rf, ctx) {
    if (rf & 1) {
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵlistener"]("click", function NgxPrintElementDirective_click_HostBindingHandler($event) {
        return ctx.onClick($event);
      });
    }
  },
  inputs: {
    print: "print"
  }
});

(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵsetClassMetadata"](NgxPrintElementDirective, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Directive,
    args: [{
      selector: '[print]'
    }]
  }], function () {
    return [{
      type: NgxPrintElementService
    }];
  }, {
    print: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
    }],
    onClick: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.HostListener,
      args: ['click', ['$event']]
    }]
  });
})();

const _c0 = ["*"];

class NgxPrintElementComponent {
  constructor(prints) {
    this.prints = prints;
  }
  /**
   * print
   * @param id
   * @param config
   */


  print(id, config) {
    this.prints.print(id, config);
  }

}

NgxPrintElementComponent.ɵfac = function NgxPrintElementComponent_Factory(t) {
  return new (t || NgxPrintElementComponent)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](NgxPrintElementService));
};

NgxPrintElementComponent.ɵcmp = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineComponent"]({
  type: NgxPrintElementComponent,
  selectors: [["ngx-print-element"]],
  exportAs: ["element"],
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function NgxPrintElementComponent_Template(rf, ctx) {
    if (rf & 1) {
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵprojectionDef"]();
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵprojection"](0);
    }
  },
  encapsulation: 2
});

(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵsetClassMetadata"](NgxPrintElementComponent, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Component,
    args: [{
      selector: 'ngx-print-element',
      template: `<ng-content></ng-content>`,
      exportAs: 'element'
    }]
  }], function () {
    return [{
      type: NgxPrintElementService
    }];
  }, null);
})();

class NgxPrintElementModule {}

NgxPrintElementModule.ɵfac = function NgxPrintElementModule_Factory(t) {
  return new (t || NgxPrintElementModule)();
};

NgxPrintElementModule.ɵmod = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineNgModule"]({
  type: NgxPrintElementModule
});
NgxPrintElementModule.ɵinj = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjector"]({});

(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵsetClassMetadata"](NgxPrintElementModule, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.NgModule,
    args: [{
      declarations: [NgxPrintElementComponent, NgxPrintElementDirective],
      exports: [NgxPrintElementComponent, NgxPrintElementDirective]
    }]
  }], null, null);
})();

(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵsetNgModuleScope"](NgxPrintElementModule, {
    declarations: [NgxPrintElementComponent, NgxPrintElementDirective],
    exports: [NgxPrintElementComponent, NgxPrintElementDirective]
  });
})();
/*
 * Public API Surface of ngx-print-element
 */

/**
 * Generated bundle index. Do not edit.
 */




/***/ })

}]);
//# sourceMappingURL=default-node_modules_ngx-print-element_fesm2020_ngx-print-element_mjs.js.map